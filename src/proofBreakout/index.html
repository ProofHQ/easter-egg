<script src="https://www.gstatic.com/firebasejs/5.5.7/firebase.js"></script>
<script>
  // Initialize Firebase
  var config = {
    apiKey: "AIzaSyAwJ0Srp3JlGL-uAy3cWEOdvh5FkYp40sA",
    authDomain: "proof-games.firebaseapp.com",
    databaseURL: "https://proof-games.firebaseio.com",
    projectId: "proof-games",
    storageBucket: "proof-games.appspot.com",
    messagingSenderId: "292429197616"
  };
  firebase.initializeApp(config);
</script>

<div id="leaderboard"></div>
<div id="prompt"></div>
<style>#proof-party{background:rgba(220,220,220, .5);display: none;left: 0px;position: fixed;top: 0px;z-index: 99999999;background}</style>

<script>
let VERSION = '1.2.1'
let canvas
let ctx

let playing = false

let x
let y
let dx
let dy
let ballRadius = 17
let initBallSpeed = 5
let ballSpeed
let ballImg = new Image()

let paddleHeight = 55
let paddleWidth = 230
let paddleX
let paddleBottomMargin = 30
let paddleSpeed = 7.5
let paddleImg = new Image()

let rightPressed = false
let leftPressed = false

let bricks = []
let brickRowCount = 7
let brickColumnCount = 12
let brickWidth
let brickHeight
let brickPadding = 20
let brickOffsetTop = 100
let brickOffsetLeft = 50

let bricksLeft
let level = 0
let score = 0
let lives = 2

color1 = '#0095f7'

function init () {
	console.log(VERSION)
  canvas = document.createElement('canvas')
  canvas.height = window.innerHeight - 20
  canvas.width = window.innerWidth - 20
  canvas.style.display = 'block'
  document.body.append(canvas)
  ctx = canvas.getContext('2d')

  ballImg.src = 'https://uploads-ssl.webflow.com/5a8b5a2ff8eb19000164d5e7/5a95e3c60f177000014a6b83_ball.png'
  paddleImg.src = 'https://uploads-ssl.webflow.com/5a8b5a2ff8eb19000164d5e7/5a9614b341e04900018aaa4c_highScore.png'

  paddleX = (canvas.width - paddleWidth) / 2

  brickHeight = canvas.height / 40
  brickWidth = canvas.width / brickColumnCount - brickPadding - (brickOffsetLeft * 2 / brickColumnCount)

  registerKeys()
  start()
  update()
}

function start () {
	level++
	ballSpeed = initBallSpeed + (level / 2)
	resetBall()
  setupBricks()
  playing = true
}

function stop () {
  playing = false
  alert (`Game over.\nYour score is ${score}`)
	document.location.reload()
}

function resetBall () {
	x = canvas.width / 2
  y = canvas.height - paddleHeight - paddleBottomMargin - 5
  dx = ballSpeed
	dy = -ballSpeed
	paddleX = (canvas.width-paddleWidth) / 2;
}

function loseLife () {
	if(lives-- == 0) {
		stop()
	} else {
		resetBall()
	}
}

// end the game
function end () {
  stop()
  canvas.remove()
}

// bind keypresses
function registerKeys () {
  // disable arrow key scrolling
  window.addEventListener('keydown', function (e) {
    if ([32, 37, 38, 39, 40].indexOf(e.keyCode) > -1) {
      e.preventDefault()
    }
  }, false)

  // paddle control
  document.addEventListener('keydown', keyDownHandler, false)
  document.addEventListener('keyup', keyUpHandler, false)
}

function keyDownHandler (e) {
  if (e.keyCode === 39) {
    rightPressed = true
  } else if (e.keyCode === 37) {
    leftPressed = true
  } else if (e.keyCode === 27) {
  	// press esc
    stop()
  }
}

function keyUpHandler (e) {
  if (e.keyCode === 39) {
    rightPressed = false
  } else if (e.keyCode === 37) {
    leftPressed = false
  }
}

// generate all of the brick positions
function setupBricks () {
  for (let c = 0; c < brickColumnCount; c++) {
    bricks[c] = []
    for (let r = 0; r < brickRowCount; r++) {
      bricks[c][r] = {x: 0, y: 0, status: 1}
    }
  }
  bricksLeft = brickRowCount * brickColumnCount
}

// draw all of the bricks
function drawBricks () {
  for (let c = 0; c < brickColumnCount; c++) {
    for (let r = 0; r < brickRowCount; r++) {
      if (bricks[c][r].status === 1) {
        let brickX = c * (brickWidth + brickPadding) + brickOffsetLeft
        let brickY = r * (brickHeight + brickPadding) + brickOffsetTop
        bricks[c][r].x = brickX
        bricks[c][r].y = brickY
        ctx.beginPath()
        ctx.rect(brickX, brickY, brickWidth, brickHeight)
        ctx.fillStyle = color1
        ctx.fill()
        ctx.closePath()
      }
    }
  }
}

function drawBall () {
  ctx.drawImage(ballImg, x, y, ballRadius * 2, ballRadius * 2)
}

function drawPaddle () {
  if (rightPressed && ((paddleX + paddleWidth) < canvas.width)) {
    paddleX += paddleSpeed
  } else if (leftPressed && paddleX > 0) {
    paddleX -= paddleSpeed
  }

  ctx.drawImage(paddleImg, paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight)
}

function drawScore() {
  ctx.font = "16px Arial"
  ctx.fillStyle = color1
  ctx.fillText("Score: " + score, 8, 20)
}

function drawLevel() {
  ctx.font = "16px Arial"
  ctx.fillStyle = color1
  ctx.fillText("Level: " + level, canvas.width / 2, 20)
}

function drawLives() {
  ctx.font = "16px Arial"
  ctx.fillStyle = color1
  ctx.fillText("lives: " + lives, canvas.width - 65, 20)
}

// check collisions between the walls and paddle
function collideWallsPaddle () {
  // left/right
  if (y + dy < ballRadius) {
    dy = -dy
  }
  // top
  if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) {
    dx = -dx
  }

  // bottom
  if (y + dy > canvas.height - ballRadius) {
    loseLife()
  }

  // paddle
	if (y > canvas.height - paddleHeight - paddleBottomMargin) {
		// top
  	if (x > paddleX && x < paddleX + paddleWidth) {
    	dy = -dy
    	collideX = paddleX + paddleWidth - x
    	if (dx > 0)
    		dx = ballSpeed - (collideX / 70)
    	else
    		dx = -ballSpeed + ((paddleWidth - collideX )/ 70)
		}
	}
}

// check collisions with bricks and ball
function collideBricks () {
  for (let c = 0; c < brickColumnCount; c++) {
    for (let r = 0; r < brickRowCount; r++) {
      let b = bricks[c][r]
      if (b.status === 1) {
      	if (x < b.x + brickWidth &&
      			x + ballRadius * 2  > b.x &&
      			y < b.y + brickHeight &&
      			y + ballRadius * 2 > b.y) {
          dy = -dy
          b.status = 0
          score += 100
          bricksLeft--
          if (bricksLeft == 0) {
          	// alert ('You win!')
          	// document.location.reload()
          	start()
          }
        }
      }
    }
  }
}

function update () {
  ctx.clearRect(0, 0, canvas.width, canvas.height)
  drawBricks()
  drawBall()
  drawPaddle()
  drawScore()
  drawLevel()
  drawLives()
  collideWallsPaddle()
  collideBricks()
  if (playing) {
    x += dx
    y += dy
  	requestAnimationFrame(update)
  }
}

// get leaderboard data
async function getStats () {
  try {
    let snap = await firebase.database().ref('breakout/stats').orderByChild('score').once('value')

  } catch (e) { }
}

// add a score to the leaderboard
async function addScore (name, score) {
  try {
    await firebase.database().ref('/breakout/stats').child(name).set({ score })
  } catch (e) { }
}

// up, up down, down, left, right, left, right, b, a
const sequence = [38, 38, 40, 40, 37, 39, 37, 39, 66, 65]
let i = 0
document.onkeydown = function (e) {
  if (e.keyCode === sequence[i]) {
    i++
  } else {
    i = 0
  }

  if (i === sequence.length) {
    init()
  }
}

// addScore('someone', 50)
getStats()

</script>

<style>
#prompt {
  display: none;
}
</style>